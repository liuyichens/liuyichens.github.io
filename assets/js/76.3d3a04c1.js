(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{564:function(a,t,s){"use strict";s.r(t);var r=s(31),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[a._v("#")]),a._v(" 内存管理")]),a._v(" "),s("p",[a._v("在任何编程语言的代码执行过程中都是需要给他分配内存的，某些编程语言要自己手动管理内存，某些编程语言可以自动管理内存。")]),a._v(" "),s("p",[a._v("内存的管理都存在生命周期")]),a._v(" "),s("ul",[s("li",[a._v("分配申请需要的内存(申请)")]),a._v(" "),s("li",[a._v("使用分配的内存(存放一些东西，例如对象等)")]),a._v(" "),s("li",[a._v("不需要使用时，对其进行释放")])]),a._v(" "),s("p",[a._v("对于开发者来说，JavaScript的内存管理是自动的、无形的。例如创建的原始值，对象，函数...这一切都会占用内存，不需要手动进行管理，JavaScript引擎会自动处理。")]),a._v(" "),s("p",[a._v("手动管理内存的语言：C、C++以及早期的OC (malloc和free函数)")]),a._v(" "),s("p",[a._v("自动管理内存的语言：Java、JavaScript、Python等。")]),a._v(" "),s("h2",{attrs:{id:"javascript的内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript的内存管理"}},[a._v("#")]),a._v(" JavaScript的内存管理")]),a._v(" "),s("p",[a._v("JavaScript会在定义数据时分配内存")]),a._v(" "),s("p",[a._v("JS对于原始数据类型内存的分配会在执行时，直接在栈空间进行分配。")]),a._v(" "),s("p",[a._v("JS对于复杂的数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.staticaly.com/gh/liuyichens/blog_img@main/image.7fa7pps0ysw0.webp",alt:"image"}})]),a._v(" "),s("h2",{attrs:{id:"javascript的内存回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript的内存回收"}},[a._v("#")]),a._v(" JavaScript的内存回收")]),a._v(" "),s("p",[a._v("内存的大小是有限的，当内存不再需要的时候，需要对其进行释放，腾出更多的内存空间。")]),a._v(" "),s("p",[a._v("手动管理内存的语言中，通过一些方式自己来释放不再需要的内存，比如free函数：")]),a._v(" "),s("ul",[s("li",[a._v("这种管理的方式非常低效，影响编写逻辑的代码的效率；")]),a._v(" "),s("li",[a._v("且这种方式对开发者的要求也很高，并且一不小心就会产生内存泄露")])]),a._v(" "),s("p",[a._v("大部分现代的编程语言都是有自己的垃圾回收机制")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("垃圾回收")]),a._v("的英文是Garbage Collection，简称GC")]),a._v(" "),s("li",[a._v("对于那些不再使用的对象，都称之为是垃圾，它需要被回收，以释放更多的内存空间")]),a._v(" "),s("li",[a._v("比如Java的运行环境JVM，JavaScript的运行环境js引擎都会使用垃圾回收器")])]),a._v(" "),s("h2",{attrs:{id:"常见的gc算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的gc算法"}},[a._v("#")]),a._v(" 常见的GC算法")]),a._v(" "),s("p",[a._v("GC怎么知道哪些对象是不再使用的呢？就要用到GC的实现以及对应的算法")]),a._v(" "),s("h3",{attrs:{id:"引用计数-reference-counting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引用计数-reference-counting"}},[a._v("#")]),a._v(" 引用计数(Reference counting)")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("当一个对象有一个引用指向它时，那么这个对象的引用就+1；")])]),a._v(" "),s("li",[s("p",[a._v("当一个对象的引用为0时，这个对象就可以被销毁掉；")])]),a._v(" "),s("li",[s("p",[a._v("这个算法有一个很大的弊端就是会产生循环引用")])])]),a._v(" "),s("h3",{attrs:{id:"标记清除-mark-sweep"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记清除-mark-sweep"}},[a._v("#")]),a._v(" 标记清除 (mark-sweep)")]),a._v(" "),s("ul",[s("li",[a._v("标记清除的核心思路是"),s("strong",[a._v("可达性")]),a._v("（Reachability）")]),a._v(" "),s("li",[a._v("这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象；")]),a._v(" "),s("li",[a._v("这个算法可以很好的解决循环引用的问题")])]),a._v(" "),s("h3",{attrs:{id:"其它算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其它算法"}},[a._v("#")]),a._v(" 其它算法")]),a._v(" "),s("p",[s("strong",[a._v("JS引擎比较广泛的采用的就是可达性中的标记清除算法，当然类似于V8引擎为了进行更好的优化，它在算法的实现细节上也会结合一些其他的算法")])]),a._v(" "),s("h4",{attrs:{id:"标记整理-mark-compact"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标记整理-mark-compact"}},[a._v("#")]),a._v(" 标记整理（Mark-Compact）")]),a._v(" "),s("ul",[s("li",[a._v("和“标记－清除”相似")]),a._v(" "),s("li",[a._v("不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存碎片化")])]),a._v(" "),s("h4",{attrs:{id:"分代收集-generational-collection"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分代收集-generational-collection"}},[a._v("#")]),a._v(" 分代收集（Generational collection）")]),a._v(" "),s("ul",[s("li",[a._v("对象被分成两组：“新的”和“旧的”。")]),a._v(" "),s("li",[a._v("许多对象出现，完成它们的工作并很快死去，它们可以很快被清理")]),a._v(" "),s("li",[a._v("那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少")])]),a._v(" "),s("h4",{attrs:{id:"增量收集-incremental-collection"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#增量收集-incremental-collection"}},[a._v("#")]),a._v(" 增量收集（Incremental collection）")]),a._v(" "),s("ul",[s("li",[a._v("如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟")]),a._v(" "),s("li",[a._v("所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分会逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟；")])]),a._v(" "),s("h4",{attrs:{id:"闲时收集-idle-time-collection"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闲时收集-idle-time-collection"}},[a._v("#")]),a._v(" 闲时收集（Idle-time collection）")]),a._v(" "),s("ul",[s("li",[a._v("垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响")])]),a._v(" "),s("p",[s("strong",[a._v("这些算法的目的都是为了让垃圾回收的效率更高")])]),a._v(" "),s("h2",{attrs:{id:"闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),s("h3",{attrs:{id:"闭包的定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的定义"}},[a._v("#")]),a._v(" 闭包的定义")]),a._v(" "),s("p",[a._v("在计算机科学中对于闭包的定义")]),a._v(" "),s("ul",[s("li",[a._v("闭包(closure)又称之为"),s("strong",[a._v("词法闭包")]),a._v("或者"),s("strong",[a._v("函数闭包")])]),a._v(" "),s("li",[a._v("是在支持头等函数的编程语言中实现词法绑定的一种技术")]),a._v(" "),s("li",[a._v("闭包在实现上是一个结构体，存储了"),s("strong",[a._v("一个函数和一个关联环境")])]),a._v(" "),s("li",[a._v("闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 "),s("strong",[a._v("自由变量")]),a._v(" 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；")])]),a._v(" "),s("p",[a._v("MDN对JavaScript闭包的解释")]),a._v(" "),s("ul",[s("li",[a._v("一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）；")]),a._v(" "),s("li",[a._v("闭包让你可以在一个内层函数中访问到其外层函数的作用域；")]),a._v(" "),s("li",[a._v("在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来")])]),a._v(" "),s("p",[a._v("总结")]),a._v(" "),s("ul",[s("li",[a._v("一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包；")]),a._v(" "),s("li",[a._v("从广义的角度来说：JavaScript中的函数都是闭包；")]),a._v(" "),s("li",[a._v("从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；")])]),a._v(" "),s("h3",{attrs:{id:"闭包的访问过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的访问过程"}},[a._v("#")]),a._v(" 闭包的访问过程")]),a._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("createAdder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("adder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("num")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" count "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" num"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" adder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" adder5 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("createAdder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("adder5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 15")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" adder10 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("createAdder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("adder10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 16")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("h3",{attrs:{id:"闭包的执行过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的执行过程"}},[a._v("#")]),a._v(" 闭包的执行过程")]),a._v(" "),s("ul",[s("li",[a._v("这个时候makeAdder函数执行完毕，正常情况下我们的AO对象会被释放；")]),a._v(" "),s("li",[a._v("但是因为在0xb00的函数中有作用域引用指向了这个AO对象，所以它不会被释放掉；")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.staticaly.com/gh/liuyichens/blog_img@main/image.74f45dqui8g0.webp",alt:"image"}})]),a._v(" "),s("h3",{attrs:{id:"闭包的内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的内存泄漏"}},[a._v("#")]),a._v(" 闭包的内存泄漏")]),a._v(" "),s("p",[a._v("在上面的案例中，如果后续我们不再使用add10函数了，那么该函数对象应该要被销毁掉，并且其引用着的父作用域AO也应该被销毁掉")]),a._v(" "),s("p",[a._v("但是目前因为在全局作用域下add10变量对0xb00的函数对象有引用，而0xb00的作用域中AO（0x200）有引用，所以最终会造成这些内存都是无法被释放的")]),a._v(" "),s("p",[a._v("所以我们经常说的闭包会造成内存泄露，其实就是刚才的引用链中的所有对象都是无法释放的；")]),a._v(" "),s("h4",{attrs:{id:"解决内存泄漏问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决内存泄漏问题"}},[a._v("#")]),a._v(" 解决内存泄漏问题")]),a._v(" "),s("p",[a._v("设置 adder10 = null")]),a._v(" "),s("p",[a._v("因为当将add10设置为null时，就不再对函数对象0xb00有引用，那么对应的AO对象0x200也就不可达了；")]),a._v(" "),s("p",[a._v("在GC的下一次检测中，它们就会被销毁掉；")])])}),[],!1,null,null,null);t.default=n.exports}}]);